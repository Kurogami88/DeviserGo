package main

/* PARSE IN VALUE
1. Token Storing Method
*/
var tpAuth = `
/***
	Author: Leong Kai Khee (Kurogami)
	Date: 2020

	Generated by DeviserGO
***/

package main

import (
	"net/http"
	"os"
	"time"

	jwtmiddleware "github.com/auth0/go-jwt-middleware"
	"github.com/dgrijalva/jwt-go"
	"golang.org/x/crypto/bcrypt"
)


// AuthMiddleware checks token validity in header or in param
func AuthMiddleware(next http.Handler) http.Handler {
	envAuthKey := os.Getenv("JWT_KEY")
	if len(envAuthKey) == 0 {
		LogError("envAuthKey missing in env")
	}

	jwtMiddleware := jwtmiddleware.New(jwtmiddleware.Options{
		ValidationKeyGetter: func(token *jwt.Token) (interface{}, error) {
			return []byte(envAuthKey), nil
		},
		UserProperty: "Authorization",
		Extractor: jwtmiddleware.FromFirst(jwtmiddleware.FromAuthHeader,
			jwtmiddleware.FromParameter("Authorization")),
		SigningMethod: jwt.SigningMethodHS256,
	})

	return jwtMiddleware.Handler(AuthValidityMiddleware(next))
}

// AuthValidityMiddleware check token validity in DB
func AuthValidityMiddleware(next http.Handler) http.Handler {
	return http.HandlerFunc(func(w http.ResponseWriter, r *http.Request) {
		permitted := false

		ctx := r.Context().Value("Authorization")
		token, ok := ctx.(*jwt.Token)
		if ok {
			claims, ok := token.Claims.(jwt.MapClaims)
			if ok {
				uuid, ok := claims["jti"].(string)
				if ok {
					%s
				} else {
					LogError("[auth.go] Error casting claims.jti")
				}
			} else {
				LogError("[auth.go] Error casting jwt.MapClaims")
			}
		} else {
			LogError("[auth.go] Error casting jwt.Token")
		}

		if permitted {
			next.ServeHTTP(w, r)
		} else {
			result := DeviserResponse{HTTPStatus: 400, Result: "Invalid token"}
			result.DoResponse(w)
			return
		}
	})
}

// AuthEncryptPassword will encrypt the given string
func AuthEncryptPassword(input string) (string, error) {
	encyptedString, err := bcrypt.GenerateFromPassword([]byte(input), bcrypt.DefaultCost)
	return string(encyptedString), err
}

// AuthCreateToken returns token string
func AuthCreateToken(uuid, user, role string) (string, error) {
	envAuthKey := os.Getenv("JWT_KEY")
	envAuthDuration, err := time.ParseDuration(os.Getenv("JWT_EXPIRY_MIN") + "m")
	if err != nil {
		LogError("envAuthDuration is invalid")
		return "", err
	}

	// Create token with 1 hour expiry
	token := jwt.NewWithClaims(jwt.SigningMethodHS256, jwt.MapClaims{
		"jti":  uuid,
		"user": user,
		"role": role,
		"exp":  time.Now().Add(envAuthDuration).Unix(),
		"iat":  time.Now().Unix(),
	})
	tokenString, err := token.SignedString([]byte(envAuthKey))
	if err != nil {
		return "", err
	}

	return tokenString, nil
}
`

var tpAuthRedis = `_, err := cache.Get("Token_" + uuid).Result()
					permitted = err == nil`
var tpAuthDB = `username, ok := claims["user"].(string)
					if ok {
						role, ok := claims["role"].(string)
						if ok {
							token, _ := DBTokenRetrieveCondition("` + "`uuid`" + ` = '" + uuid + "' and ` + "`username`" + ` = '" + username + "' and ` + "`role`" + ` = '" + role + "'")
							permitted = len(token) == 1
						} else {
							LogError("[auth.go] Error casting claims.role")
						}
					} else {
						LogError("[auth.go] Error casting claims.user")
					}`
